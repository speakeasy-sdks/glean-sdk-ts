// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/utils"
	"time"
)

// FeedbackCategory - The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
type FeedbackCategory string

const (
	FeedbackCategoryAnnouncement FeedbackCategory = "ANNOUNCEMENT"
	FeedbackCategoryAutocomplete FeedbackCategory = "AUTOCOMPLETE"
	FeedbackCategoryCollections  FeedbackCategory = "COLLECTIONS"
	FeedbackCategoryFeed         FeedbackCategory = "FEED"
	FeedbackCategorySearch       FeedbackCategory = "SEARCH"
	FeedbackCategoryChat         FeedbackCategory = "CHAT"
	FeedbackCategoryNtp          FeedbackCategory = "NTP"
	FeedbackCategoryWorkflows    FeedbackCategory = "WORKFLOWS"
	FeedbackCategorySummary      FeedbackCategory = "SUMMARY"
	FeedbackCategoryGeneral      FeedbackCategory = "GENERAL"
	FeedbackCategoryPrompts      FeedbackCategory = "PROMPTS"
)

func (e FeedbackCategory) ToPointer() *FeedbackCategory {
	return &e
}
func (e *FeedbackCategory) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "ANNOUNCEMENT":
		fallthrough
	case "AUTOCOMPLETE":
		fallthrough
	case "COLLECTIONS":
		fallthrough
	case "FEED":
		fallthrough
	case "SEARCH":
		fallthrough
	case "CHAT":
		fallthrough
	case "NTP":
		fallthrough
	case "WORKFLOWS":
		fallthrough
	case "SUMMARY":
		fallthrough
	case "GENERAL":
		fallthrough
	case "PROMPTS":
		*e = FeedbackCategory(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FeedbackCategory: %v", v)
	}
}

// Event - The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
type Event string

const (
	EventClick          Event = "CLICK"
	EventContainerClick Event = "CONTAINER_CLICK"
	EventCopyLink       Event = "COPY_LINK"
	EventCreate         Event = "CREATE"
	EventDismiss        Event = "DISMISS"
	EventDownvote       Event = "DOWNVOTE"
	EventEmail          Event = "EMAIL"
	EventExecute        Event = "EXECUTE"
	EventFilter         Event = "FILTER"
	EventFirstToken     Event = "FIRST_TOKEN"
	EventFocusIn        Event = "FOCUS_IN"
	EventLastToken      Event = "LAST_TOKEN"
	EventManualFeedback Event = "MANUAL_FEEDBACK"
	EventMarkAsRead     Event = "MARK_AS_READ"
	EventMessage        Event = "MESSAGE"
	EventMiddleClick    Event = "MIDDLE_CLICK"
	EventPageBlur       Event = "PAGE_BLUR"
	EventPageFocus      Event = "PAGE_FOCUS"
	EventPageLeave      Event = "PAGE_LEAVE"
	EventPreview        Event = "PREVIEW"
	EventRelatedClick   Event = "RELATED_CLICK"
	EventRightClick     Event = "RIGHT_CLICK"
	EventSectionClick   Event = "SECTION_CLICK"
	EventSeen           Event = "SEEN"
	EventShare          Event = "SHARE"
	EventShowMore       Event = "SHOW_MORE"
	EventUpvote         Event = "UPVOTE"
	EventView           Event = "VIEW"
	EventVisible        Event = "VISIBLE"
)

func (e Event) ToPointer() *Event {
	return &e
}
func (e *Event) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CLICK":
		fallthrough
	case "CONTAINER_CLICK":
		fallthrough
	case "COPY_LINK":
		fallthrough
	case "CREATE":
		fallthrough
	case "DISMISS":
		fallthrough
	case "DOWNVOTE":
		fallthrough
	case "EMAIL":
		fallthrough
	case "EXECUTE":
		fallthrough
	case "FILTER":
		fallthrough
	case "FIRST_TOKEN":
		fallthrough
	case "FOCUS_IN":
		fallthrough
	case "LAST_TOKEN":
		fallthrough
	case "MANUAL_FEEDBACK":
		fallthrough
	case "MARK_AS_READ":
		fallthrough
	case "MESSAGE":
		fallthrough
	case "MIDDLE_CLICK":
		fallthrough
	case "PAGE_BLUR":
		fallthrough
	case "PAGE_FOCUS":
		fallthrough
	case "PAGE_LEAVE":
		fallthrough
	case "PREVIEW":
		fallthrough
	case "RELATED_CLICK":
		fallthrough
	case "RIGHT_CLICK":
		fallthrough
	case "SECTION_CLICK":
		fallthrough
	case "SEEN":
		fallthrough
	case "SHARE":
		fallthrough
	case "SHOW_MORE":
		fallthrough
	case "UPVOTE":
		fallthrough
	case "VIEW":
		fallthrough
	case "VISIBLE":
		*e = Event(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Event: %v", v)
	}
}

type FeedbackChannel string

const (
	FeedbackChannelCompany FeedbackChannel = "COMPANY"
	FeedbackChannelGlean   FeedbackChannel = "GLEAN"
)

func (e FeedbackChannel) ToPointer() *FeedbackChannel {
	return &e
}
func (e *FeedbackChannel) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "COMPANY":
		fallthrough
	case "GLEAN":
		*e = FeedbackChannel(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FeedbackChannel: %v", v)
	}
}

type Feedback struct {
	// Universally unique identifier of the event. To allow for reliable retransmission, only the earliest received event of a given UUID is considered valid by the server and subsequent are ignored.
	ID *string `json:"id,omitempty"`
	// The feature category to which the feedback applies. These should be broad product areas such as Announcements, Answers, Search, etc. rather than specific components or UI treatments within those areas.
	Category *FeedbackCategory `json:"category,omitempty"`
	// A list of server-generated trackingTokens to which this event applies.
	TrackingTokens []string `json:"trackingTokens"`
	// The action the user took within a Glean client with respect to the object referred to by the given `trackingToken`.
	Event Event `json:"event"`
	// Position of the element in the case that the client controls order (such as feed and autocomplete).
	Position *int64 `json:"position,omitempty"`
	// For type MANUAL_FEEDBACK, contains string of user feedback. For autocomplete, partial query string. For feed, string of user feedback in addition to manual feedback signals extracted from all suggested content.
	Payload     *string      `json:"payload,omitempty"`
	SessionInfo *SessionInfo `json:"sessionInfo,omitempty"`
	// The ISO 8601 timestamp when the event occured.
	Timestamp *time.Time `json:"timestamp,omitempty"`
	User      *User      `json:"user,omitempty"`
	// The path the client was at when the feedback event triggered.
	Pathname *string `json:"pathname,omitempty"`
	// Where the feedback will be sent, e.g. to Glean, the user's company, or both. If no channels are specified, feedback will go only to Glean.
	Channels []FeedbackChannel `json:"channels,omitempty"`
	// The URL the client was at when the feedback event triggered.
	URL *string `json:"url,omitempty"`
	// The UI element tree associated with the event, if any.
	UITree []string `json:"uiTree,omitempty"`
	// The UI element associated with the event, if any.
	UIElement            *string               `json:"uiElement,omitempty"`
	ManualFeedbackInfo   *ManualFeedbackInfo   `json:"manualFeedbackInfo,omitempty"`
	SeenFeedbackInfo     *SeenFeedbackInfo     `json:"seenFeedbackInfo,omitempty"`
	UserViewInfo         *UserViewInfo         `json:"userViewInfo,omitempty"`
	WorkflowFeedbackInfo *WorkflowFeedbackInfo `json:"workflowFeedbackInfo,omitempty"`
	// The application ID of the client that sent the feedback event.
	ApplicationID *string `json:"applicationId,omitempty"`
	// The agent ID of the client that sent the feedback event.
	AgentID *string `json:"agentId,omitempty"`
}

func (f Feedback) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *Feedback) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *Feedback) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *Feedback) GetCategory() *FeedbackCategory {
	if o == nil {
		return nil
	}
	return o.Category
}

func (o *Feedback) GetTrackingTokens() []string {
	if o == nil {
		return []string{}
	}
	return o.TrackingTokens
}

func (o *Feedback) GetEvent() Event {
	if o == nil {
		return Event("")
	}
	return o.Event
}

func (o *Feedback) GetPosition() *int64 {
	if o == nil {
		return nil
	}
	return o.Position
}

func (o *Feedback) GetPayload() *string {
	if o == nil {
		return nil
	}
	return o.Payload
}

func (o *Feedback) GetSessionInfo() *SessionInfo {
	if o == nil {
		return nil
	}
	return o.SessionInfo
}

func (o *Feedback) GetTimestamp() *time.Time {
	if o == nil {
		return nil
	}
	return o.Timestamp
}

func (o *Feedback) GetUser() *User {
	if o == nil {
		return nil
	}
	return o.User
}

func (o *Feedback) GetPathname() *string {
	if o == nil {
		return nil
	}
	return o.Pathname
}

func (o *Feedback) GetChannels() []FeedbackChannel {
	if o == nil {
		return nil
	}
	return o.Channels
}

func (o *Feedback) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *Feedback) GetUITree() []string {
	if o == nil {
		return nil
	}
	return o.UITree
}

func (o *Feedback) GetUIElement() *string {
	if o == nil {
		return nil
	}
	return o.UIElement
}

func (o *Feedback) GetManualFeedbackInfo() *ManualFeedbackInfo {
	if o == nil {
		return nil
	}
	return o.ManualFeedbackInfo
}

func (o *Feedback) GetSeenFeedbackInfo() *SeenFeedbackInfo {
	if o == nil {
		return nil
	}
	return o.SeenFeedbackInfo
}

func (o *Feedback) GetUserViewInfo() *UserViewInfo {
	if o == nil {
		return nil
	}
	return o.UserViewInfo
}

func (o *Feedback) GetWorkflowFeedbackInfo() *WorkflowFeedbackInfo {
	if o == nil {
		return nil
	}
	return o.WorkflowFeedbackInfo
}

func (o *Feedback) GetApplicationID() *string {
	if o == nil {
		return nil
	}
	return o.ApplicationID
}

func (o *Feedback) GetAgentID() *string {
	if o == nil {
		return nil
	}
	return o.AgentID
}
